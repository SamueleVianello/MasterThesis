plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
lambda = 10
TT = 1
mu=1
sigma = 0.31
mu_j =0
sigma_j = 0.1
Nsim = 1000
t = (0:(TT*Nsim))/(Nsim)
S0 = 100
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
lambda = 10
TT = 1
mu=1
sigma = 0.31
mu_j =0
sigma_j = 0.1
Nsim = 1000
t = (0:(TT*Nsim))/(Nsim)
S0 = 100
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
lambda = 10
TT = 1
mu=1
sigma = 0.31
mu_j =0
sigma_j = 0.1
Nsim = 1000
t = (0:(TT*Nsim))/(Nsim)
S0 = 100
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
lambda = 10
TT = 1
mu=1
sigma = 0.31
mu_j =0
sigma_j = 0.1
Nsim = 1000
t = (0:(TT*Nsim))/(Nsim)
S0 = 100
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
lambda = 10
TT = 1
mu=1
sigma = 0.31
mu_j =0
sigma_j = 0.1
Nsim = 1000
t = (0:(TT*Nsim))/(Nsim)
S0 = 100
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
lambda = 10
TT = 1
mu=1
sigma = 0.31
mu_j =0
sigma_j = 0.1
Nsim = 1000
t = (0:(TT*Nsim))/(Nsim)
S0 = 100
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
library(DEoptim)
mu_= 0.1
ss_= 0.25
lambda_= 0.3
mu2_=-0.2
sigma_=0.01
TotalTime = 15
delta<-1/252
simulationSize = 1
nbreaks=sqrt(simulationSize)
par = matrix(0,simulationSize,5)
lower = c(-3,0.00001,0.00001,-1,0.001) #lower bounds of the search
upper = c(3,2,100,1,1) #upper bounds of the search
for(i in 1:simulationSize)
{
print(paste("Simulation Number :",i))
#Simulate the path
set.seed( as.integer((as.double(Sys.time())*1000+Sys.getpid()) %% 2^31) )
x = diff(simulateJump(mu_,ss_,lambda_,mu2_,sigma_,TotalTime,delta)[,2])   # importante lasciarla col nome x
#Using the default settings for DEoptim
set.seed(1234)
outDEoptim = DEoptim(nll_jumps, x=x, delta=delta, lower = lower,upper = upper,control = list(storepopfrom = 1, itermax=2000, trace = FALSE))
#Store the parameters
par[i,] = outDEoptim$optim$bestmem
}
setwd("C:/Users/marco/Desktop/Stage Elia Mazzoni 2018/Stage Elia - Lavoro intermedio")
source("PPgen.R")
source("callMerton.R")
source("Allocazione.R")
source("ProcessoMerton.R")
source("ProcessoMertonCorrelazione.R")
source("PortfolioInsurance.R")
library(tseries)
library(mvtnorm)
library(pracma)
library(DEoptim)
library(statmod)
library(NMOF)
library(pracma)
library(DEoptim)
library(statmod)
library(readxl)
library(xlsx)
fdy <- function(dy, dt, lambda, mu, sigma, muq, sigmaq) {
mu1 <- (mu - sigma^2 / 2) * dt
mu2 <- (mu - sigma^2 / 2) * dt + muq
sig1 <- sigma * sqrt(dt)
sig2 <- sqrt(sigma^2 * dt + sigmaq^2)
pdf1 <- dnorm(dy, mean = mu1, sd = sig1)
pdf2 <- dnorm(dy, mean = mu2, sd = sig2)
pdf <- (1 - lambda * dt) * pdf1 + (lambda * dt) * pdf2
return(pdf)
}
negloglik <- function(theta, dy, dt) {
L <- fdy(dy = dy, dt = dt, lambda = theta[1],
mu = theta[2], sigma = theta[3],
muq = theta[4], sigmaq = theta[5])
nll <- -sum(log(L))
if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
nll <- 1e10
}
return(nll)
}
x_EuroStoxx<-read.xlsx(file="EuroStoxx.xlsx",sheetName = "sheet1")[,2]
dy <- diff(log(as.vector(x_EuroStoxx)))
dt <- 1 / 255
outDE <- DEoptim(negloglik,
lower = c( 0.1, -10, 1e-4, -10, 1e-4),
upper = c(100, 10, 10, 10, 10),
control = list(itermax = 500, NP = 100), dt = dt, dy = dy)
parametri=outDE$optim$bestmem
par=parametri[c(2,3,1,4,5)]
plot(x_EuroStoxx, type='l')
TotalTime=length(x_EuroStoxx)*dt
drift_1 = par[1]
sigma_1= par[2]
lambda_1=par[3]
mu_q_1=par[4]
sigma_q_1=par[5]
hist(dy,breaks=200,prob=TRUE,main="EuroStoxx",xlab="daily returns")
curve(dnorm(x, mean=mean(dy), sd=sd(dy)), add=TRUE,col="blue")
lines(sort(dy),fdy (dy=sort(dy),dt=dt, lambda=lambda_1, mu=drift_1, sigma=sigma_1,muq= mu_q_1, sigmaq=sigma_q_1),col="red")
legend("topright", legend = c("Real", "Black-Scholes","Merton"),col=c('black','blue','red'),lwd=3, pch = c(NA, NA,NA),lty=c(1,1,1))
n <- as.data.frame(read.table("data_test.txt"))
source("MertonProcess.R")
source("plot_simulations.R")
lambda = 10
TT = 1
mu=1
sigma = 0.31
mu_j =0
sigma_j = 0.1
Nsim = 1000
t = (0:(TT*Nsim))/(Nsim)
S0 = 100
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
setwd("C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code")
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
setwd("C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code")
# plot(t,CompoundPoissonProcess(lambda,TT, mu_j, sigma_j,t))
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
source("MertonProcess.R")
source("plot_simulations.R")
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
par(mfrow=c(3,1))
plot(t, res$S,pch = 20)
lines(t, S0*exp((mu-sigma*sigma*0.5)*t), type = 'l', col = 'blue')
title("S")
plot(t, res$X, pch = 20)
lines(t, (mu-sigma*sigma*0.5)*t, type = 'l', col = 'blue')
title("returns")
plot(t[-1], cumsum(res$jumps),pch = 20)
title("Compound poisson")
simulateJump=function(mu_,ss_,lambda_,mu2_,sigma_,TotalTime,delta)
{
Sn=0
times <- c(0)
while(Sn <= TotalTime)
{
n <- length(times)
u <- runif(1)
expon <- -log(u)/lambda_
Sn <- times[n]+expon
times <- c(times, Sn)
}
times=times[-length(times)]
t=seq(from=0,to=TotalTime,by=delta)
#the last time is beyond TotalTime, so i delete from the vector times
indicator=seq(from=0,to=0,length=length(t))  # if there are jumps or not between two times
jumpSize=seq(from=0,to=0,length=length(t))   # stores the size of the jump
for(m in 2:length(times))
{
for(k in 2: length(t))
{
if( t[k-1]<=times[m] && times[m]<=t[k])
{
indicator[k]=1
jumpSize[k]=rnorm(1,mean=mu2_,sd=sigma_)
}
}
}
stock=seq(from=0,to=0,length=length(t))
stock[1]=1
for(i in 2:length(t))
{
stock[i]=stock[i-1]+(mu_)*delta+ss_*sqrt(delta)*rnorm(1)+jumpSize[i]*indicator[i]
}
final=cbind(t,stock,jumpSize,indicator)
return(final)
}
View(simulateJump)
res2 = simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])
res2
t(res2)
t(as.matrix(res2))
(as.matrix(res2))
(as.matrix(res2))[1,]
(as.matrix(res2))[,1]
(as.matrix(res2))[,2]
plot(tt,ss,pch = 20)
ss = (as.matrix(res2))[,2]
tt = (as.matrix(res2))[,1]
plot(tt,ss,pch = 20)
plot(t, res$X,pch = 20)
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
plot(t, res$X,pch = 20)
n = 20
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$S)
}
plot_simulations(t,sims)
n = 20
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
}
plot_simulations(t,sims)
l= length(t)
hist(sims[,l])
?hist
hist(sims[,l],breaks = 20)
x11()
hist(sims[,l],breaks = 20)
n = 10000
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
}
?print
n = 1000
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
print(i)
}
l= length(t)
x11()
hist(sims[,l],breaks = 200)
x11()
hist(sims[,l],breaks = 20)
x11()
hist(sims[,l],breaks = 30)
View(res2)
View(res2)
n = 1000
res2 =simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])
t =(as.matrix(res2))[,1]
sims2 = (as.matrix(res2))[,2]
for (i in 2:n) {
sims2 = rbind(sims2, (as.matrix(simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])))[,2])
print(i)
}
l= length(t)
plot_simulations(t,sims2)
ulations(t,sims2)
x11()
hist(sims2[,l],breaks = 30)
mean(sims[,l])
sd(sims[,l])
mean(sims2[,l])
sd(sims2[,l])
n = 2000
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
print(i)
}
l= length(t)
x11()
hist(sims[,l],breaks = 30)
n = 2000
res2 =simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])
t =(as.matrix(res2))[,1]
sims2 = (as.matrix(res2))[,2]
for (i in 2:n) {
sims2 = rbind(sims2, (as.matrix(simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])))[,2])
print(i)
}
l= length(t)
# plot_simulations(t,sims2)
x11()
hist(sims2[,l],breaks = 30)
sims[,l]
mean(sims[,l])
sd(sims[,l])
mean(sims2[,l])
sd(sims2[,l])
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MertonProcess.R')
n = 2000
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
print(i)
}
l= length(t)
x11()
hist(sims[,l],breaks = 30)
n = 2000
res2 =simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])
t =(as.matrix(res2))[,1]
sims2 = (as.matrix(res2))[,2]
for (i in 2:n) {
sims2 = rbind(sims2, (as.matrix(simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])))[,2])
print(i)
}
l= length(t)
# plot_simulations(t,sims2)
x11()
hist(sims2[,l],breaks = 30)
sims[,l]
mean(sims[,l])
sd(sims[,l])
mean(sims2[,l])
sd(sims2[,l])
(1:10)[-1]
source('CompoundPoissonProcess.R')
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MertonProcess.R')
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MertonProcess.R')
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
plot(t, res$X,pch = 20)
# simulations
n = 2000
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
print(i)
}
l= length(t)
x11()
hist(sims[,l],breaks = 30)
library(tictoc)
install.packages("tictoc")
tic("my code")
n = 2000
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
print(i)
}
l= length(t)
x11()
hist(sims[,l],breaks = 30)
toc()
tic()
library(tictoc)
?tic
tic()
toc()
tic("my code")
n = 2000
res =MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t)
t = res$t
sims = res$X
for (i in 2:n) {
sims = rbind(sims, (MertonProcess(S0,mu,sigma,lambda,mu_j,sigma_j,TT, t))$X)
print(i)
}
l= length(t)
x11()
hist(sims[,l],breaks = 30)
toc()
tic("other code")
n = 2000
res2 =simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])
t =(as.matrix(res2))[,1]
sims2 = (as.matrix(res2))[,2]
for (i in 2:n) {
sims2 = rbind(sims2, (as.matrix(simulateJump(mu,sigma,lambda,mu_j,sigma_j,TT, t[2]-t[1])))[,2])
print(i)
}
l= length(t)
# plot_simulations(t,sims2)
x11()
hist(sims2[,l],breaks = 30)
toc()
sims[,l]
mean(sims[,l])
sd(sims[,l])
mean(sims2[,l])
sd(sims2[,l])
mean(sims[,l])
sd(sims[,l])
mean(sims2[,l])
sd(sims2[,l])
