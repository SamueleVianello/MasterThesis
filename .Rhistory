lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: index not ")
#
# L <- fdy(dy = dy, dt = dt, lambda = theta[1],
#          mu = theta[2], sigma = theta[3],
#          muq = theta[4], sigmaq = theta[5])
# nll <- -sum(log(L))
# if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
#   nll <- 1e10
# }
# return(nll)
}
x_EuroStoxx<-read.xlsx(file="EuroStoxx.xlsx",sheetName = "sheet1")[,2]
negloglik <- function(params, x, dt, n) {
# (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
j=j+1
if(j = n+1){
i=i+1
j=1
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: index not ")
#
# L <- fdy(dy = dy, dt = dt, lambda = theta[1],
#          mu = theta[2], sigma = theta[3],
#          muq = theta[4], sigmaq = theta[5])
# nll <- -sum(log(L))
# if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
#   nll <- 1e10
# }
# return(nll)
}
negloglik(1:16, 1,1,1)
negloglik <- function(params, x, dt, n) {
# (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
j=j+1
if(j = n+1){
i=i+1
j=1
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: index not ")
#
# L <- fdy(dy = dy, dt = dt, lambda = theta[1],
#          mu = theta[2], sigma = theta[3],
#          muq = theta[4], sigmaq = theta[5])
# nll <- -sum(log(L))
# if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
#   nll <- 1e10
# }
# return(nll)
}
negloglik <- function(params, x, dt, n) {
# (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
j=j+1
if(j == n+1){
i=i+1
j=1
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: index not ")
#
# L <- fdy(dy = dy, dt = dt, lambda = theta[1],
#          mu = theta[2], sigma = theta[3],
#          muq = theta[4], sigmaq = theta[5])
# nll <- -sum(log(L))
# if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
#   nll <- 1e10
# }
# return(nll)
}
negloglik(1:16, 1,1,1)
negloglik(1:16, 1,1,2)
negloglik <- function(params, x, dt, n) {
# (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
j=j+1
if(j == n+1){
i=i+1
j=1
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
print(mu)
print(S)
print(theta)
print(delta)
print(lambda)
print(alpha)
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: indicization not correct not correct")
#
# L <- fdy(dy = dy, dt = dt, lambda = theta[1],
#          mu = theta[2], sigma = theta[3],
#          muq = theta[4], sigmaq = theta[5])
# nll <- -sum(log(L))
# if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
#   nll <- 1e10
# }
# return(nll)
}
negloglik(1:16, 1,1,2)
negloglik <- function(params, x, dt, n) {
# (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
S[j,i] =  S[i,j]
j=j+1
if(j == n+1){
j=j+1
i=j
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
print(mu)
print(S)
print(theta)
print(delta)
print(lambda)
print(alpha)
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: indicization not correct not correct")
#
# L <- fdy(dy = dy, dt = dt, lambda = theta[1],
#          mu = theta[2], sigma = theta[3],
#          muq = theta[4], sigmaq = theta[5])
# nll <- -sum(log(L))
# if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
#   nll <- 1e10
# }
# return(nll)
}
negloglik(1:16, 1,1,2)
negloglik <- function(params, x, dt, n) {
# (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
S[j,i] =  S[i,j]
j=j+1
if(j == n+1){
i=i+1
j=i
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
print(mu)
print(S)
print(theta)
print(delta)
print(lambda)
print(alpha)
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: indicization not correct not correct")
#
# L <- fdy(dy = dy, dt = dt, lambda = theta[1],
#          mu = theta[2], sigma = theta[3],
#          muq = theta[4], sigmaq = theta[5])
# nll <- -sum(log(L))
# if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
#   nll <- 1e10
# }
# return(nll)
}
negloglik(1:16, 1,1,2)
n=3
n^2*0.5+11*n*0.5+3
negloglik(1:24, 1,1,3)
negloglik(1:24, 1,1,n=3)
dim(S)
dim(SS)
rmvnorm(())
rmvnorm(5)
rmvnorm(5, mean = m,sigma = SS)
param=c(m,c(SS[1,1],SS[1,2],SS[2,2]), thet,delt,lambd,thet_z,delt_z,lambd_z,alph)
xx = rmvnorm(100, mean = m, sigma = SS)
negloglik(param, xx, dt=0.1, n = 2)
negloglik = function(params, x, dt, n) {
#
# x is a matrix [Npoints * n] of all the points for which we compute the likelihood
#
#
## add check on inputs
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
S[j,i] =  S[i,j]
j=j+1
if(j == n+1){
i=i+1
j=i
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
# print(mu)
# print(S)
# print(theta)
# print(delta)
# print(lambda)
# print(alpha)
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: number of parameters is wrong.")
partial = 0
for(i in 1:dim(x)[1]){
partial = partial + log(MultivariateMertonPdf(x[i,], dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha))
}
nll = -(partial)
if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
nll = 1e10
}
return(nll)
}
negloglik(param, xx, dt=0.1, n = 2)
warnings()
xx = rmvnorm(1, mean = m, sigma = SS)
negloglik(param, xx, dt=0.1, n = 2)
negloglik = function(params, x, dt, n) {
#
# x is a matrix [Npoints * n] of all the points for which we compute the likelihood
#
#
## add check on inputs
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
S[j,i] =  S[i,j]
j=j+1
if(j == n+1){
i=i+1
j=i
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
# print(mu)
# print(S)
# print(theta)
# print(delta)
# print(lambda)
# print(alpha)
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: number of parameters is wrong.")
partial = 0
for(i in 1:dim(x)[1]){
pdf = MultivariateMertonPdf(x[i,], dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
cat("\npdf:")
print(pdf)
partial = partial + log(pdf)
}
nll = -(partial)
if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
nll = 1e10
}
return(nll)
}
param=c(m,c(SS[1,1],SS[1,2],SS[2,2]), thet,delt,lambd,thet_z,delt_z,lambd_z,alph)
xx = rmvnorm(1, mean = m, sigma = SS)
negloglik(param, xx, dt=0.1, n = 2)
xx = rmvnorm(1, mean = m, sigma = SS)
negloglik(param, xx, dt=dt, n = 2)
xx = rmvnorm(100, mean = m, sigma = SS)
negloglik(param, xx, dt=dt, n = 2)
xx = rmvnorm(100, mean = m, sigma = SS)
negloglik(param, xx, dt=dt, n = 2)
(1:10)<4
sum((1:10)<4)
if(sum(lamda*dt>=1) || lambda_z*dt >=1)
0
MultivariateMertonPdf = function(x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha){
# Computes the density of a multivariate merton model returns with idiosyncratic and common jumps
# NOTE: all vectors should be vertical [n*1]
# ASSUMPTION: in dt time we can only have 0 or 1 jumps in each jump process, so lambda*dt<=1
#
# INPUT
# x:      vector representing at which point to compute the density [vector of n]
# mu:     drift of the continuos part [vector of n]
# S:      covariance of the continuous part [matrix n*n]
# theta:  means of the idiosyncratic jump intensity [vector of n]
# delta:  variances of the idiosyncratic jump intensity [vector of n]
# lambda:  poisson parameters of the idiosyncratic jump part [vector of n]
# theta_z: mean of common jump intensity
# delta_z: variance of common jump intensity
# lambda_z: poisson parameter of common jump part
# alpha:  vector of coefficient that multiply the common jump effect for each component
# check on lambdas:
if(sum(lambda*dt>=1) || lambda_z*dt >=1){
stop("Error: lambda*dt should be lower than 1 (ideally closer to 0).")
}
n = length(x)
cov_z = alpha%*%t(alpha)*delta_z
mu_z = theta_z*alpha
pdf = 0
# tot_prob = 0 # serves as check
for(k in 0:(2^(n+1)-1)){
mean_x = mu
cov_x = S
prob = 1
k_bin = as.binary(k,n = n+1,littleEndian=T)
# building probability and conditional density
for (i in 1:(n+1)){
if ( i<n+1){
if ( k_bin[i]){
prob = prob*lambda[i]*dt
mean_x[i] = mean_x[i] + theta[i]
cov_x[i,i] = cov_x[i,i] + delta[i]
}
else{
prob = prob*(1-lambda[i]*dt)
}
}
else{
if ( k_bin[i]){
prob = prob*lambda_z*dt
mean_x = mean_x + mu_z
cov_x = cov_x + cov_z
}
else
prob = prob*(1-lambda_z*dt)
}
}
# cat("*********************** iteration", k,"\n")
# # print(k_bin)
# cat("\nmean of x:","\n")
# print( mean_x)
# cat("\ncov of x:","\n")
# print(cov_x)
# print(pdf)
# adding each term
# tot_prob = tot_prob + prob
partial_pdf = dmvnorm(x,mean = mean_x, sigma = cov_x)
pdf = pdf + prob*partial_pdf
# cat("\nPartial pdf:")
# print(partial_pdf)
# cat("\n\n")
}
return(pdf)
}
negloglik(param, xx, dt=0.1, n = 2)
negloglik(param, xx, dt=dt, n = 2)
