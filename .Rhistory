# }
# return(nll)
}
negloglik(1:16, 1,1,2)
n=3
n^2*0.5+11*n*0.5+3
negloglik(1:24, 1,1,3)
negloglik(1:24, 1,1,n=3)
dim(S)
dim(SS)
rmvnorm(())
rmvnorm(5)
rmvnorm(5, mean = m,sigma = SS)
param=c(m,c(SS[1,1],SS[1,2],SS[2,2]), thet,delt,lambd,thet_z,delt_z,lambd_z,alph)
xx = rmvnorm(100, mean = m, sigma = SS)
negloglik(param, xx, dt=0.1, n = 2)
negloglik = function(params, x, dt, n) {
#
# x is a matrix [Npoints * n] of all the points for which we compute the likelihood
#
#
## add check on inputs
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
S[j,i] =  S[i,j]
j=j+1
if(j == n+1){
i=i+1
j=i
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
# print(mu)
# print(S)
# print(theta)
# print(delta)
# print(lambda)
# print(alpha)
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: number of parameters is wrong.")
partial = 0
for(i in 1:dim(x)[1]){
partial = partial + log(MultivariateMertonPdf(x[i,], dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha))
}
nll = -(partial)
if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
nll = 1e10
}
return(nll)
}
negloglik(param, xx, dt=0.1, n = 2)
warnings()
xx = rmvnorm(1, mean = m, sigma = SS)
negloglik(param, xx, dt=0.1, n = 2)
negloglik = function(params, x, dt, n) {
#
# x is a matrix [Npoints * n] of all the points for which we compute the likelihood
#
#
## add check on inputs
idx =1
mu = params[idx:(idx+n-1)]
idx = idx+n
S = matrix(rep(0,n*n), ncol = n)
i=1
j=1
for(k in 1:(n*(n+1)/2)){
S[i,j] = params[idx+k-1]
S[j,i] =  S[i,j]
j=j+1
if(j == n+1){
i=i+1
j=i
}
}
idx = idx + n*(n+1)/2
theta = params[idx:(idx+n-1)]
idx = idx+n
delta = params[idx:(idx+n-1)]
idx = idx+n
lambda = params[idx:(idx+n-1)]
idx = idx+n
theta_z = params[idx]
idx = idx+1
delta_z = params[idx]
idx = idx+1
lambda_z = params[idx]
idx = idx+1
alpha = params[idx:(idx+n-1)]
idx = idx+n
# print(mu)
# print(S)
# print(theta)
# print(delta)
# print(lambda)
# print(alpha)
if( (idx-1)!=length(params))
stop("Error in parameter reconstruction: number of parameters is wrong.")
partial = 0
for(i in 1:dim(x)[1]){
pdf = MultivariateMertonPdf(x[i,], dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
cat("\npdf:")
print(pdf)
partial = partial + log(pdf)
}
nll = -(partial)
if (is.nan(nll) | is.na(nll) | is.infinite(nll)) {
nll = 1e10
}
return(nll)
}
param=c(m,c(SS[1,1],SS[1,2],SS[2,2]), thet,delt,lambd,thet_z,delt_z,lambd_z,alph)
xx = rmvnorm(1, mean = m, sigma = SS)
negloglik(param, xx, dt=0.1, n = 2)
xx = rmvnorm(1, mean = m, sigma = SS)
negloglik(param, xx, dt=dt, n = 2)
xx = rmvnorm(100, mean = m, sigma = SS)
negloglik(param, xx, dt=dt, n = 2)
xx = rmvnorm(100, mean = m, sigma = SS)
negloglik(param, xx, dt=dt, n = 2)
(1:10)<4
sum((1:10)<4)
if(sum(lamda*dt>=1) || lambda_z*dt >=1)
0
MultivariateMertonPdf = function(x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha){
# Computes the density of a multivariate merton model returns with idiosyncratic and common jumps
# NOTE: all vectors should be vertical [n*1]
# ASSUMPTION: in dt time we can only have 0 or 1 jumps in each jump process, so lambda*dt<=1
#
# INPUT
# x:      vector representing at which point to compute the density [vector of n]
# mu:     drift of the continuos part [vector of n]
# S:      covariance of the continuous part [matrix n*n]
# theta:  means of the idiosyncratic jump intensity [vector of n]
# delta:  variances of the idiosyncratic jump intensity [vector of n]
# lambda:  poisson parameters of the idiosyncratic jump part [vector of n]
# theta_z: mean of common jump intensity
# delta_z: variance of common jump intensity
# lambda_z: poisson parameter of common jump part
# alpha:  vector of coefficient that multiply the common jump effect for each component
# check on lambdas:
if(sum(lambda*dt>=1) || lambda_z*dt >=1){
stop("Error: lambda*dt should be lower than 1 (ideally closer to 0).")
}
n = length(x)
cov_z = alpha%*%t(alpha)*delta_z
mu_z = theta_z*alpha
pdf = 0
# tot_prob = 0 # serves as check
for(k in 0:(2^(n+1)-1)){
mean_x = mu
cov_x = S
prob = 1
k_bin = as.binary(k,n = n+1,littleEndian=T)
# building probability and conditional density
for (i in 1:(n+1)){
if ( i<n+1){
if ( k_bin[i]){
prob = prob*lambda[i]*dt
mean_x[i] = mean_x[i] + theta[i]
cov_x[i,i] = cov_x[i,i] + delta[i]
}
else{
prob = prob*(1-lambda[i]*dt)
}
}
else{
if ( k_bin[i]){
prob = prob*lambda_z*dt
mean_x = mean_x + mu_z
cov_x = cov_x + cov_z
}
else
prob = prob*(1-lambda_z*dt)
}
}
# cat("*********************** iteration", k,"\n")
# # print(k_bin)
# cat("\nmean of x:","\n")
# print( mean_x)
# cat("\ncov of x:","\n")
# print(cov_x)
# print(pdf)
# adding each term
# tot_prob = tot_prob + prob
partial_pdf = dmvnorm(x,mean = mean_x, sigma = cov_x)
pdf = pdf + prob*partial_pdf
# cat("\nPartial pdf:")
# print(partial_pdf)
# cat("\n\n")
}
return(pdf)
}
negloglik(param, xx, dt=0.1, n = 2)
negloglik(param, xx, dt=dt, n = 2)
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
rm(MultivariateMertonPdf_2assets_nojumps)
255*8
setwd("C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code")
n = 2
m = (c(0,0))
SS = matrix(c(0.8, 0.2,
0.2, 0.1),ncol = 2)
thet = (c(0.5,1.1))
delt = (c(0.1,0.3))
lambd = (c(30,20))
thet_z = 1
delt_z = 0.5
lambd_z = 10
alph = (c(1,2))
xx = rbind(c(0,0))
dt = 1/255
param=c(m,c(SS[1,1],SS[1,2],SS[2,2]), thet,delt,lambd,thet_z,delt_z,lambd_z,alph)
xx = rmvnorm(1000, mean = m*dt, sigma = SS*dt)
start_time <- Sys.time()
negloglik(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
lx =lapply(seq_len(nrow(xx)), function(i) xx[i,])
start_time <- Sys.time()
vnegloglik(param, lx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
start_time <- Sys.time()
negloglik_2assets(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
library(tseries)
library(mvtnorm)
library(pracma)
library(DEoptim)
library(statmod)
library(NMOF)
xx = rmvnorm(1000, mean = m*dt, sigma = SS*dt)
start_time <- Sys.time()
negloglik(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
lx =lapply(seq_len(nrow(xx)), function(i) xx[i,])
start_time <- Sys.time()
vnegloglik(param, lx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
start_time <- Sys.time()
negloglik_2assets(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
xx = rmvnorm(1000, mean = m*dt, sigma = SS*dt)
start_time <- Sys.time()
negloglik(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
lx =lapply(seq_len(nrow(xx)), function(i) xx[i,])
start_time <- Sys.time()
vnegloglik(param, lx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
start_time <- Sys.time()
negloglik_2assets(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
lx =lapply(seq_len(nrow(xx)), function(i) xx[i,])
start_time <- Sys.time()
vnegloglik(param, lx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
start_time <- Sys.time()
negloglik_2assets(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
require(binaryLogic)
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
start_time <- Sys.time()
negloglik(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
lx =lapply(seq_len(nrow(xx)), function(i) xx[i,])
start_time <- Sys.time()
vnegloglik(param, lx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
start_time <- Sys.time()
negloglik_2assets(param, xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
# no common jump
start_time <- Sys.time()
negloglik_2assets_nocommon(params = c(m,c(SS[1,1],SS[1,2],SS[2,2]), thet,delt,lambd), xx, dt=dt, n = 2)
end_time <- Sys.time()
end_time-start_time
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
control_list = list(itermax = 1000, NP = 200, strategy = 6,trace=5)
bounds = BoundsCreator(2, n_common=1)
start_time <- Sys.time()
outDE <- DEoptim(negloglik_2assets,
lower = bounds$lower,
upper = bounds$upper,
control = control_list, dt = dt, x = xx, n=2)
bounds_nocommon = BoundsCreator(2, n_common=0)
start_time <- Sys.time()
outDE <- DEoptim(negloglik_2assets_nocommon,
lower = bounds_nocommon$lower,
upper = bounds_nocommon$upper,
control = control_list, dt = dt, x = xx, n=2)
end_time <- Sys.time()
end_time-start_time
bounds_nocommon = BoundsCreator(2, n_common=0)
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
bounds_nocommon = BoundsCreator(2, n_common=0)
bounds_nocommon = BoundsCreator(2, n_common=0)
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
start_time <- Sys.time()
bounds_nocommon = BoundsCreator(2, n_common=0)
bounds
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
bounds_nocommon = BoundsCreator(2, n_common=0)
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
bounds_nocommon = BoundsCreator(2, n_common=0)
start_time <- Sys.time()
outDE <- DEoptim(negloglik_2assets_nocommon,
lower = bounds_nocommon$lower,
upper = bounds_nocommon$upper,
control = control_list, dt = dt, x = xx, n=2)
end_time <- Sys.time()
end_time-start_time
ParametersReconstruction(outDE$optim$bestmem)
source('C:/Users/marco/Desktop/Stage Samuele Vianello 2018/Stage Samuele - code/MultivariateMertonModel.R')
ParametersReconstruction(outDE$optim$bestmem,2,common = FALSE)
7/5
1/255
1.4/255
library(xlsx)
my_data = read.xlsx("XBT Correlations.xlsm", sheetName = "STATIC")
library(xlsx)
my_data = read.xlsx("XBT Correlations.xlsm", sheetName = "STATIC")
my_data
bitcoin = my_data[[2]]
bitcoin
bitcoin = my_data[[2]][4:]
bitcoin = as.array(my_data[[2]])[4:]
bitcoin[3]
bitcoin[4:]
bitcoin[4]
bitcoin[4:100]
bitcoin = as.vector(my_data[[2]])[4:]
bitcoin = as.vector(my_data[[2]])[c(-1,-2,-3)]
bitcoin = as.double(bitcoin)
bitcoin
plot(bitcoin)
plot(bitcoin[1:(255*4)]
plot(bitcoin[1:(255*4)]
)
plot(bitcoin[1:(255*4)])
plot(bitcoin[1:(255*4)],type='l')
my_data = read.xlsx("XBT Correlations.xlsm", sheetName = "STATIC")
View(my_data)
bitcoin = list(date = my_data[1], value =  my_data[2])
plot(bitcoin$date,bitcoin$value,type='l')
bitcoin$date
bitcoin$value
255*4
plot(bitcoin$date[1:1020],bitcoin$value[1:1020],type='l')
plot(bitcoin$date[1:1020,],bitcoin$value[1:1020,],type='l')
which(is.na(bitcoin))
which(is.nan(bitcoin))
which(is.nan(bitcoin$date))
which(is.nan(bitcoin$date))
bitcoin$date
bitcoin = list(date = as.vector(my_data[1]), value =  as.vector(my_data[2]))
plot(bitcoin$date[1:1020,],bitcoin$value[1:1020,],type='l')
plot(bitcoin$date[1:1020,],bitcoin$value[1:1020,],type='l')
plot(bitcoin$date[1:102,],bitcoin$value[1:102,],type='l')
plot(bitcoin$date,bitcoin$value,type='l')
length(bitcoin$date)
sp500 = list(date = as.vector(my_data[5]), value =  as.vector(my_data[6]))
plot(bitcoin$date,bitcoin$value,type='l')
plot(bitcoin$date[1:500,],bitcoin$value[1:500,],type='l')
lines(sp500$date[1:500,],sp500$value[1:500,],col='green')
plot(bitcoin$date[1:200,],bitcoin$value[1:200,],type='l')
lines(sp500$date[1:200,],sp500$value[1:200,],col='green')
plot(sp500$date[1:200,],sp500$value[1:200,],col='green')
plot(sp500$date[1:200,],sp500$value[1:200,],type = 'l',col='green')
btc_x = bitcoin$value[1:500]
btc_x = bitcoin$value[1:500,]
btc_x
btc_x = bitcoin$value[1:500,]
sp500 = sp500$value[1:500,]
btc_x = as.double(bitcoin$value[1:500,])
sp500 = sp500$value[1:500,]
bitcoin = list(date = as.vector(my_data[1]), value =  as.vector(my_data[2]))
sp500 = list(date = as.vector(my_data[5]), value =  as.vector(my_data[6]))
sp500_x = sp500$value[1:500,]
library(tseries)
library(mvtnorm)
library(pracma)
library(pracma)
library(DEoptim)
library(statmod)
library(NMOF)
#* (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
n = 2
m = (c(0,0))
SS = matrix(c(0.8, 0.2,
0.2, 0.1),ncol = 2)
thet = (c(0.5,1.1))
delt = (c(0.1,0.3))
lambd = (c(30,20))
thet_z = 1
delt_z = 0.5
lambd_z = 10
alph = (c(1,2))
xx = rbind(c(0,0))
dt = 1/255
dmvnorm(xx,mean = m, sigma = SS)
res =MultivariateMertonPdf(xx, dt=dt, m,SS,thet,delt,lambd,thet_z,delt_z, lambd_z, alph)
res
source("MultivariateMertonModel.R")
#####   chiamata delle librerie
library(tseries)
library(mvtnorm)
library(pracma)
library(DEoptim)
library(statmod)
library(NMOF)
library(readxl)
library(xlsx)
library(binaryLogic)
##### testing the mvMertonpdf
#* (x, dt, mu, S, theta, delta, lambda, theta_z, delta_z, lambda_z, alpha)
n = 2
m = (c(0,0))
SS = matrix(c(0.8, 0.2,
0.2, 0.1),ncol = 2)
thet = (c(0.5,1.1))
delt = (c(0.1,0.3))
lambd = (c(30,20))
thet_z = 1
delt_z = 0.5
lambd_z = 10
alph = (c(1,2))
xx = rbind(c(0,0))
dt = 1/255
dmvnorm(xx,mean = m, sigma = SS)
res =MultivariateMertonPdf(xx, dt=dt, m,SS,thet,delt,lambd,thet_z,delt_z, lambd_z, alph)
res
xx = rmvnorm(1000, mean = m*dt, sigma = SS*dt)
assets = cbind(btc_x,sp500_x)
dt = 1/255
dt = 1/255
control_list = list(itermax = 500, NP = 200, strategy = 6,trace=5)
### no common jump
bounds_nocommon = BoundsCreator(2, n_common=0)
start_time <- Sys.time()
outDE <- DEoptim(negloglik_2assets_nocommon,
lower = bounds_nocommon$lower,
upper = bounds_nocommon$upper,
control = control_list, dt = dt, x = assets, n=2)
assets = cbind(log(btc_x[1:499]-btc_x[2:500]),log(sp500_x[1:499]-sp500_x[2:500]))
View(assets)
assets = cbind(log(btc_x[1:499]/btc_x[2:500]),log(sp500_x[1:499]/sp500_x[2:500]))
dt = 1/255
control_list = list(itermax = 500, NP = 200, strategy = 6,trace=5)
bounds_nocommon = BoundsCreator(2, n_common=0)
start_time <- Sys.time()
outDE <- DEoptim(negloglik_2assets_nocommon,
lower = bounds_nocommon$lower,
upper = bounds_nocommon$upper,
control = control_list, dt = dt, x = assets, n=2)
end_time <- Sys.time()
end_time-start_time
control_list = list(itermax = 2000, NP = 200, strategy = 6,trace=5)
### no common jump
bounds_nocommon = BoundsCreator(2, n_common=0)
start_time <- Sys.time()
outDE <- DEoptim(negloglik_2assets_nocommon,
lower = bounds_nocommon$lower,
upper = bounds_nocommon$upper,
control = control_list, dt = dt, x = assets, n=2)
end_time <- Sys.time()
end_time-start_time
ParametersReconstruction(outDE$optim$bestmem,2,common = FALSE)
plot(assets[,1])
plot(assets[,1],type = 'l')
lines(assets[,2],col='green')
plot(assets[,2],type = 'l')
lines(assets[,1],col='green')
